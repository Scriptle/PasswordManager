---
layout: post
title: Rethinking the Database Structure
date: 2019-02-24
---
### Changing the Database Structure
Currently, we have main database in which we store the user's email, hashed password and salt when they register with the program. We were planning to create a database of passwords for each user which would be encrypted and located by their email address. But, if we are going to encrypt each user's password database, surely we could remove the main database and be left with a password database per user. Each database file would be named by hashing the user's email (for privacy reasons) and each file would be encrypted using AES-256 encryption with a key generated from the user's password. AES-256 encryption is military grade encryption so is very hard to break meaning all the user's passwords would be safe in the database.
### Implementing the Change
Firstly, when the user registers, we need to generate a blank *.db* database file. This file will be stored in `\AppData\Roaming\PasswordManager`. The name of the database file is generated by hashing the username (everything before the @) of the user's email address. The username is hashed using a salt of the domain (everything after the @). The code for this process is shown below.
```java
String[] emailArray = email.split("@");
char[] username = emailArray[0].toCharArray();
byte[] domain = emailArray[1].getBytes();
byte[] hashedEmailBytes = hash(username, domain);
```
The first line takes the email inputted by the user and splits it according to the delimiter, in our case, *@* and returns an array of the two halves of the email address - the username and the domain.
Our hashing method takes in the data to be hashed as a character array so we have to convert the username, which is a string, to a character array before we can pass it to the *hash()* method. This is shown on the second line.
And, our hashing method takes the salt as a byte array so we have to convert the domain, which is also a string, to a byte array so we can pass it to the method. This is shown on the third line.
Once passed through the hash method, we get a byte array which not suitable for naming a file, so we must convert it to a hex string. The code to do this is shown below.
```java
StringBuilder builder = new StringBuilder();
for(byte b: bytes) {
	builder.append(String.format("%02x", b));
}
String hexString = builder.toString();
```
The StringBuilder object is as the name suggests, it helps to build a string.
We have to iterate through each byte in the byte array, convert the byte into a hexadecimal character and add it to the StringBuilder object. Let's break down what `%02x` means:

 - `0` means the result will be padded with zeros if it doesn't meet the specified length
 - `2` means the result will have a length of 2
 - `x` means convert to a lowercase hex character

